import {nanoid} from "nanoid"

function encode(text){
    return text.replaceAll("<", "&#60;").replaceAll(">", "&#62;")
}

export default [
    {
        id: nanoid(),
        title: "Introduction",
        body: `This handbook was created following the Scrimba React Basics course. Its purpose is to act as a reminder of the basic principles and syntax of the React framework. <p>Go to the Contents list and click on an item to read more about the topic and see examples of the syntax.`,
        selected: true,
    },
    {
        id: nanoid(),
        title: "JSX",
        body: `JSX is an extension of the JavaScript language based on ES6, and is translated into regular JavaScript at runtime. JSX syntax is almost identical to HTML syntax. A JSX element is a JavaScript object that describes the DOM element to be rendered.<p>When using a React app (e.g. Vite or create-react-app) you will need to import React into every .jsx or .js file that uses JSX: <blockquote><kbd>${encode('import React from "react"')}</kbd></blockquote><p><span class="bold">Things to remember:</span>
        <ul><li>in JSX a self-closing tag must include the closing slash e.g. <kbd>${encode('<img src="/whatever.jpg" />')}</kbd></li><li>Major differences from regular HTML:<ul class="code-element"><li>"className" for "class"</li><li>${encode('<textarea value={stateValue} /> for <textarea>Text goes here</textarea>')}</li><li>With form labels use "htmlFor" instead of "for"</li></ul></li></ul>`,
        selected: false,
    },
    {
        id: nanoid(),
        title: "Set up React",
        body: `<ul><li class="bottom-margin">The cheat's way is to paste these three lines into the HTML head section:<br /> <blockquote><kbd>${encode("<script crossorigin src='https://unpkg.com/react@17/umd/react.development.js'></script>")}</kbd><br /> <kbd>${encode("<script crossorigin src='https://unpkg.com/react-dom@17/umd/react-dom.development.js'></script>")}</kbd><br /><kbd>${encode("<script src='https://unpkg.com/babel-standalone@6/babel.min.js'></script>")}</kbd></blockquote> Then in the main script tag in html body add <kbd>type="text/babel"</kbd></li><li>Alternatively, if you want to deploy your app later use Vite to create a local React app:<br /><br /><ol><li>Ensure node.js and npm are installed on your machine.</li><li>Open the terminal at the folder in which you want to put your project.</li><li>Type <kbd>npm create vite@latest</kbd></li><li>Choose project name</li><li>Select framework: react</li><li>Select variant: javascript</li><li>Let it work its magic then .....</li><li>Type <kbd>cd (project name)</kbd> to change directory</li><li>Type <kbd>npm install</kbd></li><li>Type <kbd>npm run dev</kbd></li><li>Finally ctrl + click on the link to the local server.</li></ol><br />If you close the browser you can reopen the app on the local server by opening the terminal at the project folder and typing <kbd>npm run dev</kbd>. Then ctrl + click on the link to the local server.<br /><br /><span class="bold">To use images in a React app:</span> You should import the images as per examples in newly created React app. This is because the bundler will alter your links when you deploy the app. Alternatively you can put all your images directly in the public folder and link to them as follows: <kbd>src="/image-name.jpg\"</kbd></li></ul>`,
        selected: false,
    },
    {
        id: nanoid(),
        title: "Render to the HTML Page",
        body: `Put a root element in the HTML body:<blockquote><kbd>${encode('<div id="root"></div>')}</kbd></blockquote><p> Then in the index.js page import ReactDOM and add the render statement: <blockquote><kbd>import ReactDOM from "react-dom"<br /><br />${encode('ReactDOM.render(<App />, document.getElementById("root"))')}</kbd></blockquote> You can render any JSX code e.g.: <blockquote><kbd>${encode('ReactDOM.render(<h1 className="heading">Hi there!</h1>, document.getElementById("root"))')}</kbd></blockquote><p>With JSX we can only return a single JSX element, so if the JSX consists of more than one element they must be wrapped in a single parent element e.g. <blockquote><kbd>${encode('<div><h1>I am a heading</h1><p>I am a paragraph</p></div>')}</kbd></blockquote><p>You can even wrap it in empty tags: <kbd>${encode('<></>')}</kbd><p>If you are saving the JSX block to a variable or returning it from a function it also needs to be surrounded by brackets () if the expression is split into more than one line: <blockquote><kbd>const myJSX = (<ul class="code-element"><liclass="no-bullets">${encode('<div>')}<ul><li class="no-bullets">${encode('<h1>I am a heading</h1>')}</li><li class="no-bullets">${encode('<p>I am a paragraph</p>')}</li></ul></li class="no-bullets"><liclass="no-bullets">${encode('</div>')}</li></ul>)<br /><br />ReactDOM.render(myJSX, document.getElementById("root"))</kbd></blockquote><p><span class="bold">React Version 18 update -</span> import and render as follows: <blockquote><kbd>import ReactDOM from "react-dom/client"<br /><br />${encode('ReactDOM.createRoot(document.getElementById("root")).render(<App />)')}</kbd></blockquote>`,
        selected: false,
    },
    {
        id: nanoid(),
        title: "Deploy",
        body: `<ol><li>For a simple babel folder deploy directly to Netlify. Go to "app.netlify.com/drop" and drag and drop the whole folder (not the individual files) or use the browse facility and upload it.<br /><br /></li><li>For a Vite app push the folder to GitHub and deploy to Netlify as you would a vanilla JavaScript folder. Go to the Set up React page to read about how to ensure the images render. </li></ol>`,
        selected: false,
    },
    {
        id: nanoid(),
        title: "Functional Components",
        body: `The component is a javaScript function that returns a block of JSX code. The function name must begin with an upper-case letter (pascal case) and is called in angle brackets as a self-closing tag:<blockquote><kbd>import React from "react"<br />import ReactDOM from "react-dom"<br><br>function MyJSX() {<ul class="code-element"><li class="no-bullets">return (<ul><li class="no-bullets">${encode('<div>')}</li><ul><li class="no-bullets">${encode('<h1>I am a heading</h1>')}</li><li class="no-bullets">${encode('<p>I am a paragraph</p>')}</li></ul><li class="no-bullets">${encode('</div>')}</li></ul></li><li class="no-bullets">)</li></ul>}<br><br>${encode('ReactDOM.render(<MyJSX />, document.getElementById("root"))')}</kbd></blockquote><br /><br />You can add class names to the JSX tags for styling. The keyword is "className" in JSX:<blockquote><kbd>${encode('<h1 className="main-heading">I am a heading</h1>')}</kbd></blockquote>`,
        selected: false,
    },
    {
        id: nanoid(),
        title: "Parent/Child Components",
        body: `Build each child component in its own module. By convention the module will have the same name as its function e.g. <kbd>Header.js</kbd>. Export the function by default: <blockquote><kbd>import React from "react"<br><br>export default function Header() {<ul class="code-element"><li class="no-bullets">return (<ul><li class="no-bullets">${encode('<div className="header-container">')}</li><ul><li class="no-bullets">${encode('<img className="logo" src="./my-logo.png" />')}</li><li class="no-bullets">${encode('<h1>I am a heading</h1>')}</li></ul><li class="no-bullets">${encode('</div>')}</li></ul></li><li class="no-bullets">)</li></ul>}<br><br></kbd></blockquote>Build the parent component by calling instances of child components. Remember to import each child component: <blockquote><kbd>import React from "react"<br />import ReactDOM from "react-dom"<br />import Header from "./Header\"<br />import Main from "./Main"<br><br>function App() {<ul class="code-element"><li class="no-bullets">return (<ul><li class="no-bullets">${encode('<div>')}</li><ul><li class="no-bullets">${encode('<Header />')}</li><li class="no-bullets">${encode('<Main />')}</li></ul><li class="no-bullets">${encode('</div>')}</li></ul></li><li class="no-bullets">)</li></ul>}<br><br>${encode('ReactDOM.render(<App />, document.getElementById("root"))')}</kbd></blockquote><span class="bold">Good practice:</span> Keep all child components in a separate "components" folder.`,
        selected: false,
    },
    {
        id: nanoid(),
        title: "JS inside JSX",
        body: `You can put JavaScript inside a JSX block simply by surrounding it with curly braces {}. For example:<blockquote><kbd>function App() {<ul class=\"code-element\"><li class="no-bullets">const timeOfDay = "morning"</li><li class="no-bullets">const collective = "folks"<br /><br /></li><li class="no-bullets">return (<ul><li class="no-bullets">${encode('<h1>Good {timeOfDay} {collective}!</h1>')}</li></ul></li><li class="no-bullets">)</li></ul>}</kbd></blockquote>Renders as:<blockquote>Good morning folks!</blockquote><br />You can even do JavaScript logic inside the curly braces:<blockquote><kbd>function App() {<ul class=\"code-element\"><li class="no-bullets">const date = new Date()<br /><br /></li><li class="no-bullets">return (<ul><li class="no-bullets">${encode('<h1>It is currently about {date.getHours() % 12} o\'clock!</h1>')}</li></ul></li><li class="no-bullets">)</li></ul>}</kbd></blockquote>`,
        selected: false,
    },
    {
        id: nanoid(),
        title: "Props",
        body: `Props (properties) are like variables that are passed from parent to child component. They can then be passed down from child to grandchild components and so on as required. You choose the name for the prop just as you would for a normal variable.<ol><li>Pass the props from the parent (${encode('<App />')}) to the child (${encode('<Pet />')})component:<blockquote><kbd>function App() {<ul><li class="no-bullets">return(<ul><li class="no-bullets">${encode('<div className="animal-cards">')}<ul><li class="no-bullets">${encode('<Pet')}<ul><li class="no-bullets">type="cat"</li> <li class="no-bullets">name="Honey"</li> <li class="no-bullets">favFood="Dreamies"</li> </ul></li><li class="no-bullets">${encode('/>')}</li></ul></li><li class="no-bullets">${encode('</div>')}</li></ul></li><li class="no-bullets">)</li></ul>}<br /><br /></kbd></blockquote></li><li>The child component receives the props (The word "props" is used by convention, but it could be anything you choose.): <blockquote><kbd>function Pet(props) {<ul><li class="no-bullets">${encode('return <p>{props.name} is a {props.type}. Her favourite food is {props.favFood}</p>')}</li></ul>}</kbd></blockquote>Renders: <blockquote>Honey is a cat. Her favourite food is Dreamies.</blockquote>Alternatively you can destructure the props object as soon as it is passed down to the child component:<blockquote><kbd>function Pet({name, type, favFood}) {<ul><li class="no-bullets">${encode('return <p>{name} is a {type}. Her favourite food is {favFood}</p>')}</li></ul>}</kbd></blockquote></li></ol>You can pass props of any data type e.g. number, boolean, function, array etc. To pass a prop which is not a string simply enclose it in curly braces {}. For example: <kbd>hasFur={true}</kbd> or <kbd>numberOfLegs={4}</kbd> or <kbd>diet={["Dreamies", "Whiskas", "mice"]}</kbd><br /><br /><span class="bold">Note regarding links to images:</span> if you are passing a fragment of a link - for example a specific image in an images folder - use a template literal within curly braces to consume it in the child component: <blockquote><kbd>${encode('<img src={`../images/${props.img}`} />')}</kbd></blockquote>`,
        selected: false,
    },
    {
        id: nanoid(),
        title: "Conditional Rendering",
        body: `<ul><li class="bottom-margin">If something should only be rendered under certain conditions use the following syntax within the JSX block:<blockquote><kbd>${encode('{props.title && <h3>title: {props.title}</h3>}')}</kbd></blockquote>This means that the ${encode('<h3>')} tag should only be rendered if props.title has a truthy value.</li><li class="bottom-margin">Alternatively, if there is a lot of JavaScript logic to deal with, then do that logic in the function before the return statement, and then use it in the JSX, e.g. using an if / else statement to set the value of a variable which will determine how the JSX will render. </li><li class="bottom-margin">You can use the ternary operator if you want to render either one thing or another depending on a condition:<blockquote><kbd>${encode('<button onClick={toggleShown}>{isShown ? "Hide" : "Show"} Punchline</button>')}</kbd></blockquote>In the above example, if "isShown" is truthy then the button text will read "Hide Punchline", whereas if it is falsy it will read "Show Punchline".</li><li class="bottom-margin">For more complex conditional rendering you should write the logic inside the function component (but before the JSX return statement) for example by using a variable and if / else statements (or switch statement). Then use the variable within the JSX. </li></ul>`,
        selected: false,
    },
    {
        id: nanoid(),
        title: "Mapping Components",
        body: `If you want to render several instances of a component, based on an array of objects you would use the .map() method to generate an array of instances and save the array of instances to a variable. You would then use the variable directly where you want it rendered in the JSX. So, suppose you have an array of data called petsData. The array contains a series of objects with a set of key: value pairs for each pet. The following example assumes the pet objects have an id value, a name value and a species value: <blockquote><kbd>function App() {<ul class="code-element"><li class="no-bullets">const pets = petsData.map(pet => {<ul><li class="no-bullets">${encode('return <Pet')} key={pet.id} name={pet.name} species={pet.species} ${encode('/>')}</li></ul></li><li class="no-bullets">})<br /><br /></li><li class="no-bullets">return (<ul><li class="no-bullets">${encode('<section className="pets-container">')}<ul><li class="no-bullets">{pets}</li></ul></li><li class="no-bullets">${encode('</section>')}</li></ul></li><li class="no-bullets">)</li></ul>}</kbd></blockquote> An instance of the ${encode('<Pet />')} component will be rendered for each object in the petsData array.<blockquote><kbd>function Pet(props) {<ul class="code-element"><li class="no-bullets">${encode('return <p>{props.name} is a {props.type}</p>')}</li></ul>}</kbd></blockquote><span class="bold">When exporting a data array from a data file</span> it is sufficient to write <kbd>export default [</kbd> without explicitly assigning it to a variable. You can then assign the name when importing thus: <kbd>import data from "./data"</kbd><br /><br /><span class="bold">Remember to include the key prop in each mapped element.</span> This should be a unique reference such as an object id value, and can be generated using nanoid() which should be imported from the node module thus: <kbd>import {nanoid} from "nanoid"</kbd> `,
        selected: false,
    },
    {
        id: nanoid(),
        title: "Pass the Array Object",
        body: `You don't have to pass props individually when mapping from a data set consisting of an array of objects. Instead, you can pass the whole object (the example assumes the pet objects have an id value, a name value and a species value): <blockquote><kbd>function App() {<ul class="code-element"><li class="no-bullets">const pets = petsData.map(pet => {<ul><li class="no-bullets">${encode('return <Pet')} key={pet.id} item={pet} ${encode('/>')}</li></ul></li><li class="no-bullets">})<br /><br /></li><li class="no-bullets">return (<ul><li class="no-bullets">${encode('<section className="pets-container">')}<ul><li class="no-bullets">{pets}</li></ul></li><li class="no-bullets">${encode('</section>')}</li></ul></li><li class="no-bullets">)</li></ul>}</kbd></blockquote> The ${encode('<Pet />')} component will look like this:<blockquote><kbd>function Pet(props) {<ul class="code-element"><li class="no-bullets">${encode('return <p>{props.item.name} is a {props.item.type}</p>')}</li></ul>}</kbd></blockquote><span class="bold">Alternatively</span> you can pass the spread object: <blockquote><kbd>function App() {<ul class="code-element"><li class="no-bullets">const pets = petsData.map(pet => {<ul><li class="no-bullets">${encode('return <Pet')} key={pet.id} item={...pet} ${encode('/>')}</li></ul></li><li class="no-bullets">})<br /><br /></li><li class="no-bullets">return (<ul><li class="no-bullets">${encode('<section className="pets-container">')}<ul><li class="no-bullets">{pets}</li></ul></li><li class="no-bullets">${encode('</section>')}</li></ul></li><li class="no-bullets">)</li></ul>}</kbd></blockquote> This is the equivalent of passing the object's individual properties, so the ${encode('<Pet />')} component will look like this:<blockquote><kbd>function Pet(props) {<ul class="code-element"><li class="no-bullets">${encode('return <p>{props.name} is a {props.type}</p>')}</li></ul>}</kbd></blockquote>`,
        selected: false,
    },
    {
        id: nanoid(),
        title: "Event Listeners",
        body: `The function to be executed when the event takes place should be added inside the function component. Then put the event listener directly into the event target JSX DOM element as an html attribute and call the function in curly braces. Don't add opening and closing brackets after the function name in the curly braces. The event name should be in camel case: <blockquote><kbd>function App() {<ul class="code-element" ><li class="no-bullets">function handleClick() {<ul><li class="no-bullets">console.log("I was clicked!")</li></ul></li> <li class="no-bullets">}<p></li> <li class="no-bullets">return (<ul><li class="no-bullets">${encode('<div className="container">')}<ul><li class="no-bullets">${encode('<img src="./images/my-image.jpg" />')}<li class="no-bullets">${encode('<button onClick={handleClick}>Click me</button>')}</ul></li><li class="no-bullets">${encode('</div>')}</li> </ul></li> <li class="no-bullets">)</li></ul>}</kbd></blockquote>Note that a DOM event such as onClick can only exist on a native DOM element, and not on a function so this <span class="bold">will not work</span>: <blockquote><kbd>${encode('<Child onClick={handleClick} />')}</kbd></blockquote>`,
        selected: false,
    },
    {
        id: nanoid(),
        title: "State",
        body: `State is declared at the beginning of the function component. It is similar to a variable that is designed to be changed. The value passed to the useState method is used when the component initially renders. When state is changed the component re-renders. Just like a variable, state can be in the form of various data types e.g. string, number, boolean, array, object. It is often in the form of an array of objects. State is declared using the following syntax: <blockquote><kbd>const [isHappy, setIsHappy] = React.useState(true)</kbd></blockquote>or <blockquote><kbd>const [saladIngredients, setSaladIngredients] = React.useState(["avocado", "lentils", "baby spinach"])</kbd></blockquote> or <blockquote><kbd>const [timeOfDay, setTimeOfDay] = React.useState("morning")</kbd></blockquote>The first variable in the destructured array is the state and the second is a function which will be used to change the state.<p>This is how you would use the state in the JSX:<blockquote><kbd>function Tally(){<ul class="code-element"><li class="no-bullets">const [number, setNumber] = React.useState(1)<p></li><li class="no-bullets">${encode('return <h3>{number}</h3>')}</li></ul>}</kbd></blockquote>The number 1 would render in an ${encode('<h3> element.')}<br /><br /><br /><span class="bold">Alternatively</span> you can import useState from the React library at the top of the file: <blockquote><kbd>import React, {useState} from "react"</kbd></blockquote> and initiate state as follows:<blockquote><kbd>const [isHappy, setIsHappy] = useState(true)</kbd></blockquote>`,
        selected: false,
    },
    {
        id: nanoid(),
        title: "Set State",
        body: `A simple change of state is easy to declare: <blockquote><kbd>function Color(){<ul class="code-element"><li class="no-bullets">const [color, setColor] = React.useState("blue")<p></li><li class="no-bullets"><li class="no-bullets">function changeToRed() {<ul><li class="no-bullets">setColor("red")</li></ul></li><li class="no-bullets">}<p></li></li><li class="no-bullets">${encode('return <h3 onClick={changeToRed}>{color}</h3>')}</li></ul>}</kbd></blockquote>In the above case the string "blue" is rendered in the ${encode('<h3>')} element. When the element is clicked the word "blue" changes to "red". It is usual to put the event handler function inside the function component.`,
        selected: false,
    },
    {
        id: nanoid(),
        title: "Set State From Previous",
        body: `If you new state depends on the previous state you cannot modify the state directly. So for example to increment by one you could use the following syntax: <blockquote><kbd>const [count, setCount] = React.useState(0)<br /><br />function add() {<ul class="code-element"><li class="no-bullets">setCount(count + 1)</li></ul>}</kbd></blockquote>NOT<blockquote><kbd>function add() {<ul class="code-element"><li class="no-bullets">setCount(count++)</li></ul>}</kbd></blockquote>This is because <kbd>count++</kbd> is short for <kbd>count = count + 1</kbd>, which would be modifying the value of state (in this case count).<p><span class="bold">But best practice says that</span> whenever we need to use our old state value to determine the new value we should pass a callback function to the state setter function, with a parameter to represent the previous state (e.g. previousValue or prev) thus: <blockquote><kbd>function add() {<ul class="code-element"><li class="no-bullets">setCount(prev => prev + 1)</li></ul>}</kbd></blockquote>`,
        selected: false,
    },
    {
        id: nanoid(),
        title: "State - Flip a Boolean",
        body: `To toggle a boolean state: <blockquote><kbd>const [isHungry, setIsHungry] = React.useState(true)<br /><br />function toggleIsHungry() {<ul class="code-element"><li class="no-bullets">setIsHungry(prev => !prev)</li></ul>}</kbd></blockquote>Then in the return statement you can use a ternary to reflect the changing state in the UI:<blockquote><kbd>${encode('<div onClick={toggleIsHungry}>')}<ul class="code-element"><li class="no-bullets">${encode('<h3>{isHungry ? "Feed Me!" : "No thanks!"}</h3>')}</li></ul>${encode('</div>')}</kbd></blockquote>`,
        selected: false,
    },
    {
        id: nanoid(),
        title: "Complex State - Arrays",
        body: `If your state is an array you cannot modify it directly. Neither can you modify prev directly. For example, if you want to add the next counting number to an array in state <span class="bold"> you can't do this:</span><blockquote><kbd>${encode('setNumbersArray(prev => prev.push(`${prev.length + 1}`)')}</kbd></blockquote>Instead, you can make a new array by using the spread operator to copy all the items in the previous array, and then add the next item like this:<blockquote><kbd>${encode('setNumbersArray(prev => [...prev, `${prev.length + 1}`])')}</kbd></blockquote>`,
        selected: false,
    },
    {
        id: nanoid(),
        title: "Complex State - Objects",
        body: `If state is an object and you want to change the value of one of the properties, you could use the spread operator when updating state:<blockquote><kbd>const [cat, setCat] = React.useState({<ul class="code-element"><li class="no-bullets">name: "Honey",</li><li class="no-bullets">isHungry: true</li></ul>})</kbd></blockquote>Then to toggle isHungry:<blockquote><kbd>function toggleIsHungry() {<ul class="code-element"><li class="no-bullets">setCat(prev => {<ul><li class="no-bullets">return {<ul><li class="no-bullets">...prev,</li><li class="no-bullets">isHungry: !prev.isHungry</li></ul></li><li class="no-bullets">}</li></ul> </li><li class="no-bullets">})</li></ul>}</kbd></blockquote>This has the effect of copying all the object properties into a new object and then overwriting the property or properties that need to be updated. This might look a bit hacky, but it is the accepted way to do it.<p><span class="bold">If you want to make an implicit return in the set state callback function</span> you would need to surround the object to be returned in brackets () to prevent the object curly braces from being mis-interpreted as function curly braces:<blockquote><kbd>function toggleIsHungry() {<ul class="code-element"><li class="no-bullets">setCat(prev => ({<ul><li class="no-bullets">...prev,</li><li class="no-bullets">isHungry: !prev.isHungry</li></ul> </li><li class="no-bullets">})</li></ul>}</kbd></blockquote>`,
        selected: false,
    },
    {
        id: nanoid(),
        title: "State as a Prop",
        body: `You can pass state from parent to child component just as you would pass any other prop. For example, if a state called "name" is set in the parent component it is passed down to the child component as follows:<blockquote><kbd>const [name, setName] = React.useState("Honey")</kbd></blockquote> <blockquote><kbd>${encode('<Child name={name} />')}</kbd></blockquote>The child component will receive it as a normal prop and use it within the JSX:<blockquote><kbd>function Child(props) {<ul class="code-element"><li class="no-bullets">${encode('return <h3>Name: {props.name}</h3>')}</li></ul>}</kbd></blockquote><p> <span class="bold">Note that</span> when the state updates both parent and child components will re-render.`,
        selected: false,
    },
    {
        id: nanoid(),
        title: "Functions as Props",
        body: `State setter functions are often passed down from parent component to child component as they exist in the same component as the state to be changed. In this example it is the child component that updates the state using the function handleClick() that has been passed down from the parent.<p>This is the parent component: <blockquote><kbd>function App() {<ul class="code-element"><li class="no-bullets">const [isHungry, setIsHungry] = React.useState(true)<br /><br /></li><li class="no-bullets">function handleClick() {<ul><li class="no-bullets">setIsHungry(prev => !prev)</li> </ul></li> <li class="no-bullets">}<br /><br /></li><li class="no-bullets">return (<ul><li class="no-bullets">${encode('<div className="cat-wrapper">')}<ul><li class="no-bullets">${encode('<h2>Dinner time!</h2>')}</li><li class="no-bullets">${encode('<Cat')}<ul><li class="no-bullets">isHungry={isHungry}</li><li class="no-bullets">handleClick={handleClick}</li></ul></li><li class="no-bullets">${encode('/>')}</li></ul></li><li class="no-bullets">${encode('</div>')}</li></ul></li><li class="no-bullets">)</li></ul>}</kbd></blockquote>And this is the child component: <blockquote><kbd>function Cat(props) {<ul class="code-element"><li class="no-bullets">const hungerStatement = props.isHungry ? "Great, I'm hungry!" : "But I'm not hungry!"<br /><br /></li><li class="no-bullets">return (<ul><li class="no-bullets">${encode('<div className="is-hungry-wrapper">')}<ul><li class="no-bullets">${encode('<h4>{hungerStatement}</h4>')}</li><li class="no-bullets">${encode('<button onClick={props.handleClick}>Toggle hunger</button>')}</li></ul></li><li class="no-bullets">${encode('</div>')}</li></ul> </li><li class="no-bullets">)</li></ul>}</kbd></blockquote> Note that a DOM event such as onClick can only exist on a native DOM element, and not on a function so this <span class="bold">will not work</span>: <blockquote><kbd>${encode('<Child onClick={handleClick} />')}</kbd></blockquote>`,
        selected: false,
    },
    {
        id: nanoid(),
        title: "Pass Parameters Back",
        body: `An event handler function is automatically given the event as a parameter. We do not have to explicitly pass it in when it is called from the event target: <blockquote><kbd>${encode('<form onSubmit={handleSubmit}> .... </form>')}<br /><br />function handleSubmit(event) {<ul class="code-element"><li class="no-bullets">event.preventDefault()</li><li class="no-bullets">console.log(formData)</li></ul>}</kbd></blockquote>However, if the event handler function requires additional parameters - for example and element id - this parameter needs to be passed by means of a callback function on the event target: <blockquote><kbd>
        function deleteNote(event, noteId) {<ul class="code-element"><li class="no-bullets">event.stopPropogation()</li><li class="no-bullets">setNotes(oldNotes => oldNotes.filter(note => note.id !== noteId))</li></ul>}<br /><br />return(<ul class="code-element"><li class="no-bullets">${encode('<Sidebar')}<ul><li class="no-bullets">....</li><li class="no-bullets">deleteNote={deleteNote}</li></ul></li><li class="no-bullets">${encode('/>')}</li></ul>)</kbd></blockquote>Here the deleteNote() function and the return statement are both sitting in the parent component function. The child component function ${encode('<Sidebar />')} passes its id up to the deleteNote() function as a parameter using a callback function as follows: <blockquote><kbd>${encode('<button')}<ul class="code-element"><li class="no-bullets">onClick={(event) => props.deleteNote(event, note.id)}</li></ul>${encode('></button>')}</kbd></blockquote>`,
        selected: false,
    },
    {
        id: nanoid(),
        title: "The Data Flow",
        body: `Data flows down the component hierarchy from parents to children. Components cannot pass data to their siblings. If siblings need to share data or functions the data or functions must be kept in the parent component (or other ancestor) and passed down as required. As a general rule it is good practice to keep the data as low down the component hierarchy as possible.<p>However, it is usually not recommended to set state in a child component from a state prop that has been passed down to it from the parent. This is known as "derived state" and can result in bugs due to there being more than one source of state. Instead, use the state that has already been set in the parent component.`,
        selected: false,
    },
    {
        id: nanoid(),
        title: "Dynamic Styles",
        body: `You can add styling to a JSX element like this:<blockquote><kbd>${encode('<div style={{backgroundColor: "blue"}}><h1>This background is blue</h1></div>')}</kbd></blockquote>The outer set of curly braces indicates that the contents are to be read as JavaScript, while the inner set represents the object containing the styles. It is often helpful to assign the style object separately to a variable and reference the variable in the JSX: <blockquote><kbd>const styles = {<ul class="code-element"><li class="no-bullets">backgroundColor: "blue",</li><li class="no-bullets">color: "#eee"</li></ul>}<br /><br />${encode('<div style={styles}><h1>This background is blue. The text colour is light grey.</h1></div>')}</kbd></blockquote>JavaScript style attributes must be in camel case e.g. "backgroundColor", not "background-color".<br /><p>In dynamic styling the attribute value will update according to state. For example:<blockquote><kbd>const styles = {<ul class="code-element"><li class="no-bullets">backgroundColor: props.darkMode ? "black" : "white",</li><li class="no-bullets">color: "green"</li></ul>}</kbd></blockquote>In the above example if the boolean value of darkMode (which has been passed down as a prop) is true the background colour will be black. If it is false the background colour will be white.`,
        selected: false,
    },
    {
        id: nanoid(),
        title: "Arrays of Objects",
        body: `If your state is an array of objects you will need to use .map(), the spread operator and callback functions to update one of the objects: <blockquote><kbd>function App() {<ul class="code-element"><li class="no-bullets">const [squares, setSquares] = React.useState(boxes)<br /><br /></li><li class="no-bullets">function toggle(id) {<ul><li class="no-bullets">setSquares(prev => prev.map(square => square.id === id ? {...square, on: !square.on} : square))</li></ul></li><li class="no-bullets">}<br /><br /></li><li class="no-bullets">const squareElements = squares.map(square => (<ul><li class="no-bullets">${encode('<Box')} <ul><li class="no-bullets">key={square.id} </li><li class="no-bullets">id={square.id}</li><li class="no-bullets">on={square.on}</li><li class="no-bullets">toggle={toggle}</li> </ul></li><li class="no-bullets">${encode('/>')}</li></ul></li><li class="no-bullets">))<br /><br /></li><li class="no-bullets">return (<ul><li class="no-bullets">${encode('<main>')}<ul><li class="no-bullets">{squareElements}</li></ul></li><li class="no-bullets">${encode('</main>')}</li></ul></li><li class="no-bullets">)</li></ul>}</kbd></blockquote>In this example the squares state is initialised to an array "boxes". The array consists of a number of objects, each with and "id" property and and boolean "on" property. The "on" boolean is toggled from true to false when it is clicked. This is done by updating the whole array in state by mapping over the prev state and using the object spread operator and the ternary operator. If the value of the id parameter matches the object then the object is returned with the "on" property flipped. Otherwise it is returned unchanged.
        The "id" parameter is passed up from the child ${encode('<Box />')} component to the toggle() function by using a callback function within the event listener function in the child component as follows:<blockquote><kbd>function Box(props) {<ul class="code-element"><li class="no-bullets">const styles = {<ul><li class="no-bullets">backgroundColor: props.on ? "#222222" : "transparent"</ul></li><li class="no-bullets">}<br /><br /></li><li class="no-bullets">return (<ul><li class="no-bullets">${encode('<div')}<ul><li class="no-bullets">style={styles}</li><li class="no-bullets">className="box"</li><li class="no-bullets">onClick={() => props.toggle(props.id)}</li></ul></li><li class="no-bullets">${encode('>')}</li><li class="no-bullets">${encode('</div>')}</li></ul></li><li class="no-bullets">)</li></ul>}</kbd></blockquote>The callback toggle function can now pass the component's id up to the toggle function in the parent component.<p><br /> <span class="bold">Alternatively</span> you can pass the function down from the parent like this:<blockquote><kbd>toggle={() => toggle(square.id)}</kbd></blockquote>and the child can recieve it like this:<blockquote><kbd>onClick={props.toggle}</kbd></blockquote>`,
        selected: false,
    },
    {
        id: nanoid(),
        title: "Forms",
        body: `Keep all the form input values in a single state object. The syntax is as follows: 
        <blockquote><kbd>function Form() {<ul class="code-element"><li class="no-bullets">const [formData, setFormData] = React.useState(<ul><li class="no-bullets">{<ul><li class="no-bullets">firstName: "", </li><li class="no-bullets">lastName: "",</li><li class="no-bullets">email: "", </li><li class="no-bullets">comments: "",</li><li class="no-bullets">isFriendly: true,</li><li class="no-bullets">employment: "",</li><li class="no-bullets">favColor: ""</li></ul></li><li class="no-bullets">}</li></ul></li><li class="no-bullets">)<br /><br /></li>
        <li class="no-bullets">function handleChange(event) {<ul><li class="no-bullets">const {name, value, type, checked} = event.target</li> <li class="no-bullets">setFormData(prevFormData => {<ul><li class="no-bullets">return {<ul><li class="no-bullets">...prevFormData,</li><li class="no-bullets">[name]: type === "checkbox" ? checked : value</li></ul></li><li class="no-bullets">}</li></ul></li><li class="no-bullets">})</li></ul></li><li class="no-bullets">}<br /><br /></li><li class="no-bullets">return (<ul><li class="no-bullets">${encode('<form>')}<ul><li class="no-bullets">${encode('<input')}<ul><li class="no-bullets">type="text"</li><li class="no-bullets">placeholder="First Name"</li><li class="no-bullets">onChange={handleChange}</li><li class="no-bullets">name="firstName"</li><li class="no-bullets">value={formData.firstName}</li></ul></li><li class="no-bullets">${encode('/>')}</li><li class="no-bullets">${encode('<input')}<ul><li class="no-bullets">type="text"</li><li class="no-bullets">placeholder="Last Name"</li><li class="no-bullets">onChange={handleChange}</li><li class="no-bullets">name="lastName"</li><li class="no-bullets">value={formData.lastName}</li></ul></li><li class="no-bullets">${encode('/>')}</li><li class="no-bullets">${encode('<input')}<ul><li class="no-bullets">type="email"</li><li class="no-bullets">placeholder="Email"</li><li class="no-bullets">onChange={handleChange}</li><li class="no-bullets">name="email"</li><li class="no-bullets">value={formData.email}</li></ul></li><li class="no-bullets">${encode('/>')}</li><li class="no-bullets">${encode('<textarea')}<ul><li class="no-bullets">placeholder="Comments"</li><li class="no-bullets">onChange={handleChange}</li><li class="no-bullets">name="comments"</li><li class="no-bullets">value={formData.commehts}</li></ul>                 </li><li class="no-bullets">${encode('/>')}</li></ul>
        <ul><li class="no-bullets">${encode('<input')}<ul><li class="no-bullets">type="checkbox"</li><li class="no-bullets">id="isFriendly"</li><li class="no-bullets">onChange={handleChange}</li><li class="no-bullets">name="isFriendly"</li><li class="no-bullets">checked={formData.isFriendly}</li></ul></li><li class="no-bullets">${encode('/>')}</li><li class="no-bullets">${encode('<label htmlFor="isFriendly">Are you friendly?</label>')}</li><li class="no-bullets">${encode('<br />')}</li><li class="no-bullets">${encode('<br />')}<br /><br /></li><li class="no-bullets">${encode('<fieldset>')}<ul><li class="no-bullets">${encode('<legend>Current employment status</legend>')}</li><li class="no-bullets">${encode('<input')}<ul><li class="no-bullets">type="radio"</li><li class="no-bullets">id="unemployed"</li><li class="no-bullets">name="employment"</li><li class="no-bullets">value="unemployed"</li><li class="no-bullets">checked={formData.employment === "unemployed"}</li><li class="no-bullets">onChange={handleChange}</li></ul></li><li class="no-bullets">${encode('/>')}</li><li class="no-bullets">${encode('<label htmlFor="unemployed">Unemployed</label>')}</li><li class="no-bullets">${encode('<br />')}</li><li class="no-bullets">${encode('<br />')}<br /><br /></li><li class="no-bullets">${encode('<input')}<ul><li class="no-bullets">type="radio"</li><li class="no-bullets">id="part-time"</li><li class="no-bullets">name="employment"</li><li class="no-bullets">value="part-time"</li><li class="no-bullets">checked={formData.employment === "part-time"}</li><li class="no-bullets">onChange={handleChange}</li></ul></li><li class="no-bullets">${encode('/>')}</li><li class="no-bullets">${encode('<label htmlFor="part-time">Part-time</label>')}</li><li class="no-bullets">${encode('<br />')}</li><li class="no-bullets">${encode('<br />')}<br /><br /></li><li class="no-bullets">${encode('<input')}<ul><li class="no-bullets">type="radio"</li><li class="no-bullets">id="full-time"</li><li class="no-bullets">name="employment"</li><li class="no-bullets">value="full-time"</li><li class="no-bullets">checked={formData.employment === "full-time"}</li><li class="no-bullets">onChange={handleChange}</li></ul></li><li class="no-bullets">${encode('/>')}</li><li class="no-bullets">${encode('<label htmlFor="full-time">Full-time</label>')}</li><li class="no-bullets">${encode('<br />')}</li><li class="no-bullets">${encode('<br />')}</li></ul>
        </li><li class="no-bullets">${encode('</fieldset>')}</li><li class="no-bullets">${encode('<br />')}</li><li class="no-bullets">${encode('<label htmlFor="favColor">What is your favorite color?</label>')}</li><li class="no-bullets">${encode('<br />')}</li><li class="no-bullets">${encode('<select')} <ul><li class="no-bullets">id="favColor"</li><li class="no-bullets">value={formData.favColor}</li><li class="no-bullets">onChange={handleChange}</li><li class="no-bullets">name="favColor"</li></ul></li><li class="no-bullets">${encode('>')}<ul><li class="no-bullets">${encode('<option value="">-- Choose --</option>')}</li><li class="no-bullets">${encode('<option value="red">Red</option>')}</li><li class="no-bullets">${encode('<option value="green">Green</option>')}</li><li class="no-bullets">${encode('<option value="blue">Blue</option>')}</li></ul></li> <li class="no-bullets">${encode('</select>')}</li></ul></li>
        <li class="no-bullets">${encode('</form>')}</li></ul></li><li class="no-bullets">)</li></ul>}</kbd></blockquote>
        This works provided the input name is the same as its corresponding state object property key. It covers inputs, checkboxes, textareas and radio buttons. If the form does not include a checkbox the event.target type and value properties can be omitted from the handleChange() function and the statement <kbd>[name]: type === "checkbox" ? checked : value</kbd> can be changed to <kbd>[name]: value</kbd> <p>For the form to be controlled the value of each input needs to be set to the value of its corresponding state object property i.e. the state maintained in the component should be what drives the input value.`,
        selected: false,
    },
    {
        id: nanoid(),
        title: "Submit the Form",
        body: `For the form to be able to submit it needs a button element inside it. When a button is located inside a form its type defaults to "submit". The form should be given an onSubmit event handler: <blockquote><kbd>${encode('<form onSubmit={handleSubmit}> .... </form>')}</kbd></blockquote>Clicking the button automatically triggers the form's onSubmit event handler. The handleSubmit() function should include the preventDefault() method to stop the form from refreshing: <blockquote><kbd>function handleSubmit(event) {<ul class="code-element"><li class="no-bullets">event.preventDefault()</li><li class="no-bullets">console.log(formData)</li></ul>}</kbd></blockquote>`,
        selected: false,
    },
    {
        id: nanoid(),
        title: "useEffect()",
        body: `React.useEffect() is used to handle anything that lives outside of React, for example: <ul><li>localStorage</li><li>API/database interactions</li><li>Window events</li><li>Subscriptions (e.g. web sockets)</li><li>Syncing 2 different internal states together (e.g. you want something to happen every time a state variable changes)</li><li>setTimeout()</li></ul>React.useEffect() takes two parameters: the first is a callback function, and the second (optional) parameter is an array of dependencies, which indicate after which state changes the callback function should run. An empty array indicates that the callback function should run after first render only. Additionally the function will run after updating takes place to any of the states included in the dependencies array.<p> If the dependencies array is omitted then the callback will run after every render, which can result in an infinite loop if the function updates state, which re-renders, updates state and so on. <p></br />Window event example: <blockquote><kbd>const [windowWidth, setWindowWidth] = React.useState(window.innerWidth)<br /><br />
        React.useEffect(() => {<ul class="code-element"><li class="no-bullets">window.addEventListener("resize", function() {<ul><li class="no-bullets">setWindowWidth(window.innerWidth)</li></ul></li><li class="no-bullets">})</li></ul>}, [])</kbd></blockquote>You don't need anything in the dependencies array because the event listener is running every time the window is resized.<p></br />Local storage example: <blockquote><kbd>const [notes, setNotes] = React.useState(() => JSON.parse(localStorage.getItem("notes")) || [])<br /><br />React.useEffect(() => {<ul class="code-element"><li class="no-bullets">localStorage.setItem("notes", JSON.stringify(notes))</li></ul>}, [notes])</kbd></blockquote>The notes state is initialised with the notes array from local storage if it exists. If "notes" does not exist in local storage then it will initialise with an empty array. The useEffect() dependency is "notes", which means the array is set to local storage every time the notes state is updated.<p><span class="bold">Note that</span> the notes state variable is initialised with a callback function. This prevents the code from running every time a change is made, which would be quite heavy on browser resources for something like making a call to local storage. This is known as "lazy State initialisation".<p><br />
        The following example shows how useEffect can be used to sync two internal states:<blockquote><kbd>const [die, setDice] = React.useState(getDieValue())<br />const [winner, setWinner] = React.useState(false)<br /><br />React.useEffect(() => {<ul class="code-element"><li class="no-bullets">if (die.value === 6) {<ul><li class="no-bullets">setWinner(true)</li></ul></li><li class="no-bullets">}</li></ul>}, [die])</kbd></blockquote>Here the die state variable is checked every time die changes state. If the die value is 6 then the winner state variable is set to true.`,
        selected: false,
    },
    {
        id: nanoid(),
        title: "useEffect() Clean up",
        body: `In the case where we might experience a memory leak we should ensure we clean up our useEffect(). This is how we would do it:<blockquote><kbd>const [windowWidth, setWindowWidth] = React.useState(window.innerWidth)<br /><br />React.useEffect(() => {<ul class="code-element"><li class="no-bullets">function watchWidth() {<ul><li class="no-bullets">setWindowWidth(window.innerWidth)</li></ul></li><li class="no-bullets">}</li><li class="no-bullets">window.addEventListener("resize", watchWidth)</li><li class="no-bullets">return function() {<ul><li class="no-bullets">window.removeEventListener("resize", watchWidth)</li></ul></li><li class="no-bullets">}</li></ul>}, [])<br /><br />return (<ul class="code-element"><li class="no-bullets">${encode('<h1>Window width: {windowWidth}</h1>')}</li></ul>)</kbd></blockquote>Here the cleanup function is returned from the useEffect function. <p>A memory leak could occur in the case that an effect is run as part of a functional component that is not rendered to the page, for example if the element is conditionally rendered.`,
        selected: false,
    },
    {
        id: nanoid(),
        title: "APIs",
        body: `Use React.useEffect() within the component function to make an API call which will run after initial render:<blockquote><kbd>const [starWarsData, setStarWarsData] = React.useState({})<br /><br />React.useEffect(() => {<ul class="code-element"><li class="no-bullets">fetch("https://swapi.dev/api/people/1")<ul><li class="no-bullets">.then(res => res.json())</li><li class="no-bullets">.then(data => setStarWarsData(data))</li></ul></li></ul>}, [])</kbd></blockquote>If you want the function to run after other renders you need to add the appropriate state variable to the dependencies array.<p>If you want to use async await inside useEffect() the syntax is as follows:<blockquote><kbd>const [starWarsData, setStarWarsData] = React.useState({})<br /><br />React.useEffect(() => {<ul class="code-element"><li class="no-bullets">async function getStarWarsCharacter() {<ul><li class="no-bullets">const res = await fetch("https://swapi.dev/api/people/1")</li><li class="no-bullets">const data = await res.json()</li><li class="no-bullets">setStarWarsData(data)</li></ul></li><li class="no-bullets">}</li><li class="no-bullets">getStarWarsCharacter()</li></ul>}, [])<br /><br /></kbd></blockquote>`,
        selected: false,
    },
    {
        id: nanoid(),
        title: "event.stopPropogation()",
        body: `If an element with an onClick() event handler is parent to another element which also has an onClick() event handler then when you click on the child element it will also register as a click on the parent element. To avoid this you need to pass the event parameter to the child's event handler function and start the function block with <kbd>event.stopPropogation()</kbd> Example child element function:<blockquote><kbd>function deleteNote(event, noteId) {<ul class="code-element"><li class="no-bullets">event.stopPropagation()</li><li class="no-bullets">setNotes(prev => {<ul><li class="no-bullets">return prev.filter(note => noteId !== note.id)</li></ul></li><li class="no-bullets">})</li></ul>}</kbd></blockquote>`,
        selected: false,
    },
]
